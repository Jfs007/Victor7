!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.vicApp = t() : e.vicApp = t() }(self, (() => (() => { "use strict"; var e = { d: (t, o) => { for (var s in o) e.o(o, s) && !e.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: o[s] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, t = {}; e.r(t), e.d(t, { Component: () => a, changeOptions: () => d, getContext: () => g, query: () => f, register: () => m, scope: () => p, use: () => y, vic: () => _ }); const o = function (e, t) { let o = {}; return t.map((t => { o[t] = e[t] })), o }, s = function (e) { let t = e.match(/.*(\?.*)/); t && (e = t[1]); let o = {}; return e.replace(/(\w+)=?([^=&]+)?&?/g, (function (e, t, s) { o[t] = s ? s.trim() : "" })), o }, n = class { constructor(e, t) { this.console = new class { constructor() { } log(e) { console.log("[32m", e) } error(e) { return console.log(new Error(e)) } warn(e) { console.log("[33m", e) } } } init(e = {}) { for (let t in e) this[t] = e[t] } setup() { } }; let i = 0; class r { __calls = {}; constructor() { } on(e, t) { this.__calls[e] || (this.__calls[e] = {}); let o = function ({ name: e, callback: t } = options) { return { once: t.__once, callback: t, id: t.__id || `${e}-${++i}` } }({ name: e, callback: t }); this.__calls[e][o.id] = o } off(e, t) { let o = this.__calls[e]; o && (t ? Object.keys(o).find((s => { let n = o[s]; if (t == n.callback) return delete this.__calls[e][s], !0 })) : this.__calls[e] = {}) } emit(e, t) { let o = this.__calls[e]; o && Object.keys(o).map((s => { let n = o[s]; n.callback(t), n.__once && this.off(e, n.callback) })) } once(e, t) { t.__once = !0, this.on(e, t) } } const a = class extends n { __vic = {}; __app = {}; __provide = {}; __e = new r; __config = {}; constructor() { super() } inject(e = {}) { this.__inject = e } setup(e) { this.__vic = e, this.__app = e.app } config() { } behavior() { } }, c = class extends a { _name = "navigate"; alias = "$n"; pointer = null; delta = -1; define = {}; query = {}; history = []; pushRoute = ""; constructor() { super() } setup(e) { super.setup(e); let t = this; return this.define = o(this.__app, ["switchTab", "reLaunch", "redirectTo", "navigateTo", "navigateBack"]), this.define.navigateBaseTo = this.navigateBaseTo, Object.keys(this.define).map((e => { Object.defineProperty(this.__app, e, { get: function () { return t[e].bind(t) } }) })), this } setQuery(e) { let { url: t } = e; this.query = s(t) } switchTab(e = {}) { e = this.done({ options: e, routeFunction: "switchTab" }, (e => { this.history = [e] })), this.setQuery(e), this.define.switchTab.call(this.__app, e) } reLaunch(e = {}) { e = this.done({ options: e, routeFunction: "reLaunch" }, (e => { this.history = [e] })), this.setQuery(e), this.define.reLaunch.call(this.__app, e) } redirectTo(e = {}) { e = this.done({ options: e, routeFunction: "redirectTo" }, (e => { this.history.pop(), this.history.push(e) })), this.setQuery(e), this.define.redirectTo.call(this.__app, e) } navigateTo(e = {}) { e = this.done({ options: e, routeFunction: "navigateTo" }, (e => { this.history.push(e) })), this.setQuery(e), this.define.navigateTo.call(this.__app, e) } navigateBack(e = {}) { let { delta: t, url: o } = e; "base" == t && this.pointer ? (e.delta = this.getDelta(), this.base()) : e.delta = t || 1, e = this.done({ options: e, routeFunction: "navigateBack" }, (t => { this.history = this.history.slice(0, this.history.length - (e.delta || 1)) })), this.setQuery({ url: o || "" }), this.define.navigateBack.call(this.__app, e) } navigateBaseTo(e) { let t = getCurrentPages(); this.pointer = t[t.length - 1], this.delta = t.length, this.navigateTo(e) } base() { this.pointer = null, this.delta = -1 } getPureUrl(e) { return (e || "").replace(/\?.*/, "") } getUrlObject(e = "") { return { route: (e || "").replace(/\?.*/, ""), options: s(e || "") } } getDelta() { let e = this.pointer, t = this.delta; return e ? getCurrentPages().length - t : -1 } done({ options: e, routeFunction: t } = op, o = (() => { })) { this.pushRoute = ""; let s = g(), { onShow: n } = s, i = this, r = e.url, a = null; r && "navigateBack" != t ? a = this.getUrlObject(r) : (a = this.history[this.history.length - 2] || {}, r = a.route || ""); let c = r.replace(/\?.*/, ""), u = e.success; return e.success = function (t) { o(a, e), u && u(t), i.pushRoute || (i.__e.emit("onRoute", { to: a, from: s }), i.pushRoute = c.replace(/^\//, "")), s.__register || (s.onShow = function (e) { let t = i.history.slice(-1)[0], o = t.route.replace(/^\//, ""); i.pushRoute === o && (i.__e.emit("onRoute", { to: s, from: t }), i.history.pop(), i.pushRoute = s.route.replace(/^\//, "")), n.call(s, e), s.__freeze = !1 }), s.__register = !0 }, e } freezeOnShow() { getCurrentPages().map((e => { e.__register && (e.__freeze = !0) })) } compare(e, t) { return e.join("@") !== t.join("@") } onRoute(e) { this.__e.on("onRoute", e) } offRoute(e) { this.__e.off("onRoute", e) } }, u = class extends a { _name = "auth"; key = "vic-auth"; alias = "$a"; __config = { isLogin() { return this.useInfo.token } }; userInfo = { token: void 0 }; constructor() { super(), this.userInfo.token = this.getToken() } updateUserInfo(e = {}) { Object.keys(e).map((t => { let o = e[t]; this.userInfo[t] = o })) } setup(e = {}) { this.init(e) } login(e) { this.updateUserInfo(e), this.setToken(e.token) } logout() { this.updateUserInfo({ token: "" }), this.removeToken() } setToken(e) { ((e, t) => { try { wx.setStorageSync(e, t) } catch (e) { } })(this.key, e) } removeToken() { (e => { try { wx.removeStorage({ key: e }) } catch (e) { } })(this.key) } getToken() { return e = this.key, wx.getStorageSync(e); var e } isLogin() { return this.__config.isLogin.call(this) } }, l = class extends a { _name = "scene"; alias = "$s"; get navigator() { let { Navigator: e } = vic.__components; return e || {} } constructor() { super() } setup(e) { super.setup(e) } remove() { } }, h = class extends a { constructor() { super() } }, p = { Route: (e = {}) => { if (!_.__scope.Page) throw new Error('使用Route需要提前调用vic.applyScope("Page", Page)'); return Page = _.__scope.Page, Page(e) } }; let _ = new class { name = "vic"; env = null; __scope = {}; __components = { Navigate: c, Auth: u, Scene: l, LanuchApp: h }; constructor() { } setup(e) { return this.app = e, this.app[this.name] = this, Object.keys(this.__components).map((e => { this.load(this.__components[e]).setup(this) })), this } use(e, t) { this[e] = t } load(e) { let t = new e; return this[t.alias] = t, this[t._name] = t, t.inject(this), t } applyScope(e, t) { this.__scope[e] = t } }; function g() { var e = getCurrentPages(); return e[e.length - 1] } function f(e = {}) { let t = (e.context ? e.context : g() || {}).options || {}; return Object.assign({}, t, _.navigate.query || {}) } function d(e) { let t = g(); t && t.options && (t.options = Object.assign(t.options || {}, e)) } function y(e, t) { _.use(e, t) } function m(e, t) { _.__components[e] || (_.__components[e] = t, _.load(t).setup(_)) } let { onRoute: v } = function () { let e = {}, t = !1, o = ({ from: t, to: o }) => { Object.keys(e).map((e => { })) }; return { onRoute(s = {}) { e = Object.assign(e, s), t || (_.navigate.onRoute(o), t = !0) } } }(); return t })()));